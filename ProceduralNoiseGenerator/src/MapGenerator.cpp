#include "MapGenerator.h"



MapGenerator::MapGenerator(float hgrid, float vgrid, string fileName)
{
	m_hgrid = hgrid;
	m_vgrid = vgrid;
	m_map = new float*[m_vgrid];
	for (int i = 0; i < m_vgrid; ++i) {
		m_map[i] = new float[m_hgrid];
	}

	m_max = 0.0f;
	m_min = 0.0f;

	m_mapName = fileName;


	m_wnoise = NULL;
	m_snoise = NULL;
	m_pnoise = NULL;

}

void MapGenerator::createPerlinNoise(int octaves, float frequency, float amplitude, int seed, float lacunarity, float gain)
{
	m_pnoise = new PerlinNoise(octaves, frequency, amplitude, seed, lacunarity, gain);
}


void MapGenerator::createSimplexNoise(int octaves, float frequency, float amplitude, int seed, float lacunarity, float gain)
{
	m_snoise = new SimplexNoise(octaves, frequency, amplitude, seed, lacunarity, gain);
}

void MapGenerator::createWorleyNoise(int octaves, float frequency, float amplitude, int seed, float lacunarity, float gain, WorleyNoise::distanceFunctions distFunc, WorleyNoise::noiseTypes noiseType)
{
	m_wnoise = new WorleyNoise(octaves, frequency, amplitude, seed, lacunarity, gain, distFunc, noiseType);
}

//clears data inside the map and fills it with 0s

void  MapGenerator::fillMapWithNoise2D(Noise noise)
{
	float frequency = 1.0f / (float)m_hgrid;
	float octaves = 16;
	float amplitude = 1.0f;

	float min = 100000.0f;
	float max = -100000.0f;
	float pixelValue = 0.0f;
	for (int i = 0; i < m_vgrid; ++i) {
		for (int j = 0; j < m_hgrid; ++j) {
			//get the value for this pixel by adding successive layers
			switch (noise) {
			case PERLIN:
				pixelValue = m_pnoise->perlinNoise2D(j, i);
				break;

			case SIMPLEX:
				pixelValue = m_snoise->simplexNoise2D(j, i);
				break;

			case WORLEY:
				pixelValue = m_wnoise->worleyNoise2D(j, i);
				break;
			default:
				throw std::invalid_argument("Error: Undefined Noise!");
			}

			m_map[j][i] = pixelValue;

			//do some quick checks
			if (pixelValue < min) {
				min = pixelValue;
				//cout << "min: " << min << endl;
			}
			else if (pixelValue > max) {
				max = pixelValue;
				//cout << "max: " << max << endl;
			}
		}
	}
	m_min = min;
	m_max = max;
	cout << "min: " << m_min << endl;
	cout << "max: " << m_max << endl;
}




void MapGenerator::flushMap()
{
	for (int i = 0; i < m_vgrid; ++i) {
		for (int j = 0; j < m_hgrid; ++j) {
			m_map[j][i] = 0.0f;
		}
	}
}

//Helper function that prints information about the noises generated by the map and values in use by the generated noises, used for debugging purposes
void MapGenerator::printNoiseInfo() const
{
	cout << "------------------------------------------" << endl;
	cout << "        PRINTING NOISE INFORMATION        " << endl;
	cout << "------------------------------------------" << endl;
	if (m_pnoise == NULL) {
		cout << "PERLIN NOISE: NOT GENERATED" << endl;
	}
	else {
		cout << "PERLIN NOISE: GENERATED" << endl;
		cout << "Octaves: " << m_pnoise->getOctaves() << endl;
		cout << "Frequency: " << m_pnoise->getFrequency() << endl;
		cout << "Amplitude: " << m_pnoise->getAmplitude() << endl;
		cout << "Seed: " << m_pnoise->getSeed() << endl;
		cout << "Lacunarity: " << m_pnoise->getLacunarity() << endl;
		cout << "Gain: " << m_pnoise->getGain() << endl;
	}
	cout << "------------------------------------------" << endl;

	if (m_snoise == NULL) {
		cout << "SIMPLEX NOISE: NOT GENERATED" << endl;
	}
	else {
		cout << "SIMPLEX NOISE: GENERATED" << endl;
		cout << "Octaves: " << m_snoise->getOctaves() << endl;
		cout << "Frequency: " << m_snoise->getFrequency() << endl;
		cout << "Amplitude: " << m_snoise->getAmplitude() << endl;
		cout << "Seed: " << m_snoise->getSeed() << endl;
		cout << "Lacunarity: " << m_snoise->getLacunarity() << endl;
		cout << "Gain: " << m_snoise->getGain() << endl;
	}
	cout << "------------------------------------------" << endl;

	if (m_wnoise == NULL) {
		cout << "WORLEY NOISE: NOT GENERATED" << endl;
	}
	else {
		cout << "WORLEY NOISE: GENERATED" << endl;
		cout << "Octaves: " << m_wnoise->getOctaves() << endl;
		cout << "Frequency: " << m_wnoise->getFrequency() << endl;
		cout << "Amplitude: " << m_wnoise->getAmplitude() << endl;
		cout << "Seed: " << m_wnoise->getSeed() << endl;
		cout << "Lacunarity: " << m_wnoise->getLacunarity() << endl;
		cout << "Gain: " << m_wnoise->getGain() << endl;
		cout << "Distance Function Type: " << m_wnoise->getDistanceFunction() << endl;
		cout << "Noise Type: " << m_wnoise->getNoiseType() << endl;
	}
	cout << "------------------------------------------" << endl;
}

//Print grayscale image of the contents of m_map (filled with procedural noise) and save it with given imageName
void MapGenerator::printGrayscaleImage(string imageName) const
{
	int i, j, k;
	ofstream out;

	out.open(imageName, ofstream::binary);
	if (!(out.is_open())){
		cout << "ERROR: CANT OPEN THE FILE" << endl;
		exit(-1);
	}

	//3.1.2 copy the header
	//3.1.2.1 magic number
	out.put(char(66));
	out.put(char(77));

	//3.1.2.2 filsize/unused space
	for (i = 0; i<8; i++)
		out.put(char(0));

	//3.1.2.3 data offset
	out.put(char(54));

	//3.1.2.4 unused space
	for (i = 0; i<3; i++)
		out.put(char(0));

	//3.1.2.5 header size
	out.put(char(40));

	//3.1.2.6 unused space
	for (i = 0; i<3; i++)
		out.put(char(0));

	//3.1.2.7 file width (trickier)
	out.put(char(m_hgrid % 256));
	out.put(char((m_hgrid >> 8) % 256));
	out.put(char((m_hgrid >> 16) % 256));
	out.put(char((m_hgrid >> 24) % 256));

	//3.1.2.8 file height (trickier)
	out.put(char(m_vgrid % 256));
	out.put(char((m_vgrid >> 8) % 256));
	out.put(char((m_vgrid >> 16) % 256));
	out.put(char((m_vgrid >> 24) % 256));

	//3.1.2.9 color planes
	out.put(char(1));
	out.put(char(0));

	//3.1.2.10 bit depth
	out.put(char(24)); //TRY 8 BIT INSTEAD

	//3.1.2.11 the rest
	for (i = 0; i<25; i++)
		out.put(char(0));

	for (i = (m_vgrid - 1); i >= 0; i--){
		for (j = 0; j<m_hgrid; j++) {
			// clip the values between 0-255. clipping will convert [min,max] scale to [0,255] scale
			int colorVal = scale(m_map[j][i], m_min, m_max, 0, 255);
			int grayscale = ((21 * colorVal + 72 * colorVal + 7 * colorVal) / 100);

			out.put(char(grayscale));//blue
			out.put(char(grayscale));//green
			out.put(char(grayscale));//red
		}
		//round off the row
		for (k = 0; k<(m_hgrid % 4); k++)
			out.put(char(0));
	}

	//3.3 end the file
	out.close();
}

void MapGenerator::printColoredImage(string imageName) const
{
	//set up some variables
	float diff = m_max - m_min,
		flood = 0.5f,			//	flood level
		mount = 0.85f;			//	mountain level

	flood *= diff;
	mount *= diff;

	int i, j, k;

	//these can be changed for interesting results
	/*
	color landlow(0, 64, 0),
		landhigh(133, 182, 116),
		waterlow(0, 0, 55),
		waterhigh(0, 53, 106),
		mountlow(167, 157, 147),
		mounthigh(216, 223, 226);
	*/
	
	color waterlow(0, 0, 137), waterhigh(0, 93, 255),
		mounthigh(128, 0, 0), mountlow(238, 255, 9),
		landlow(80, 255, 167), landhigh(116, 244, 0);
		
	//249 255 9 mlow

	//3.0 output to file
	//3.1 Begin the file
	//3.1.1 open output file
	ofstream out;
	out.open(imageName, ofstream::binary);
	if (!(out.is_open())){
		cout << "ERROR: CANT OPEN THE FILE" << endl;
		exit(-1);
	}

	//3.1.2 copy the header
	//3.1.2.1 magic number
	out.put(char(66));
	out.put(char(77));

	//3.1.2.2 filsize/unused space
	for (i = 0; i<8; i++)
		out.put(char(0));

	//3.1.2.3 data offset
	out.put(char(54));

	//3.1.2.4 unused space
	for (i = 0; i<3; i++)
		out.put(char(0));

	//3.1.2.5 header size
	out.put(char(40));

	//3.1.2.6 unused space
	for (i = 0; i<3; i++)
		out.put(char(0));

	//3.1.2.7 file width (trickier)
	out.put(char(m_hgrid % 256));
	out.put(char((m_hgrid >> 8) % 256));
	out.put(char((m_hgrid >> 16) % 256));
	out.put(char((m_hgrid >> 24) % 256));

	//3.1.2.8 file height (trickier)
	out.put(char(m_vgrid % 256));
	out.put(char((m_vgrid >> 8) % 256));
	out.put(char((m_vgrid >> 16) % 256));
	out.put(char((m_vgrid >> 24) % 256));

	//3.1.2.9 color planes
	out.put(char(1));
	out.put(char(0));

	//3.1.2.10 bit depth
	out.put(char(24));

	//3.1.2.11 the rest
	for (i = 0; i<25; i++)
		out.put(char(0));

	//3.2 put in the elements of the array
	color newcolor(0, 0, 0);
	for (i = (m_vgrid - 1); i >= 0; i--){//bitmaps start with the bottom row, and work their way up...
		for (j = 0; j<m_hgrid; j++){//...but still go left to right
			m_map[j][i] -= m_min;
			//if this point is below the floodline...
			if (m_map[j][i]<flood)
				newcolor = lerp(waterlow, waterhigh, m_map[j][i] / flood);

			//if this is above the mountain line...
			else if (m_map[j][i]>mount)
				newcolor = lerp(mountlow, mounthigh, (m_map[j][i] - mount) / (diff - mount));

			//if this is regular land
			else
				newcolor = lerp(landlow, landhigh, (m_map[j][i] - flood) / (mount - flood));

			out.put(char(newcolor.v[2]));//blue
			out.put(char(newcolor.v[1]));//green
			out.put(char(newcolor.v[0]));//red
		}
		//round off the row
		for (k = 0; k<(m_hgrid % 4); k++)
			out.put(char(0));
	}

	//3.3 end the file
	out.close();
}


MapGenerator::~MapGenerator()
{
	for (int i = 0; i < m_vgrid; ++i) {
		delete m_map[i];
	}
	delete m_map;

	//delete noises
	if (!m_pnoise) {
		delete m_pnoise;
	}
	if (!m_snoise) {
		delete m_snoise;
	}
	if (!m_wnoise) {
		delete m_wnoise;
	}
}
